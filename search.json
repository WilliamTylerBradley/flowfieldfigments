[{"path":"https://williamtylerbradley.github.io/flowfieldfigments/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 flowfieldfigments authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Anchor Points","text":"output package starts set anchor points paths begin. vignette displays possible variation anchor points. three styles, random, spiral, diamond. number points ranges uniformly 50 1,500. paths’ starting direction length determine color generated simplex noise. following code examines pieces individually puts together comparison.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"layout","dir":"Articles","previous_headings":"","what":"Layout","title":"Anchor Points","text":"first layout style random. random yields points multivariate normal distribution. standard deviation number points, size, times four divided number digits size. size 50 100, standard deviation double size. 1,000 , ’s just size. modification tends balance images nicely range values. following images display random anchor point style middle size value 750 extremes 50 1,500. Random 750 Random 50 Random 1500 spiral next style. one follows spiral based golden ratio. output take space, smaller size values appear open larger size values denser. Unfortunately, sometimes little hole middle depending cutoffs based size. However, better result overcrowding can happen always point direct center. Spiral 750 Spiral 50 Spiral 1500 final layout diamond. tilted grid width size’s square root. paths’ movements can follow along diagonals, layout can produce rows straight lines. Diamond 750 Diamond 50 Diamond 1500","code":"library(flowfieldfigments) library(tidyverse) library(scales) library(mvtnorm) library(ambient)  # anchor_layout == \"random\" set.seed(1) size <- 750  points <- as.data.frame(mvtnorm::rmvnorm(   n = size,   sigma = diag(size * 4 / (floor(log10(size)) + 1),     nrow = 2   ) )) %>%   rename(     x = V1,     y = V2   ) %>%   mutate(id = row_number())  axes_limits <- max(c(abs(c(   points$x,   points$y ))))  ggplot(   data = points,   aes(x, y) ) +   geom_point(size = .5) +   scale_x_continuous(limits = c(-axes_limits, axes_limits)) +   scale_y_continuous(limits = c(-axes_limits, axes_limits)) +   coord_equal() +   theme_void() # anchor_layout == \"spiral\" size <- 750  golden <- ((sqrt(5) + 1) / 2) * (2 * pi)  points <- data.frame(   x = sqrt(seq(1, size)) * cos(golden * seq(1, size)) * 2.5,   y = sqrt(seq(1, size)) * sin(golden * seq(1, size)) * 2.5 ) %>%   mutate(id = row_number())  axes_limits <- max(c(abs(c(   points$x,   points$y ))))  ggplot(   data = points,   aes(x, y) ) +   geom_point(size = .5) +   scale_x_continuous(limits = c(-axes_limits, axes_limits)) +   scale_y_continuous(limits = c(-axes_limits, axes_limits)) +   coord_equal() +   theme_void() # anchor_layout == \"diamond\" size <- 750  grid_width <- ifelse(size <= 1500 / 2, ceiling(sqrt(size)), floor(sqrt(size)))  points <- expand_grid(   x_start = seq(1, grid_width) - (grid_width / 2) - .5,   y_start = seq(1, grid_width) - (grid_width / 2) - .5 ) %>%   mutate(     x = (x_start * cos(45 * pi / 180) - y_start * sin(45 * pi / 180)) * 5,     y = (x_start * sin(45 * pi / 180) + y_start * cos(45 * pi / 180)) * 5,     id = row_number()   ) %>%   select(-x_start, -y_start)  axes_limits <- max(c(abs(c(   points$x,   points$y ))))  ggplot(   data = points,   aes(x, y) ) +   geom_point(size = .5) +   scale_x_continuous(limits = c(-axes_limits, axes_limits)) +   scale_y_continuous(limits = c(-axes_limits, axes_limits)) +   coord_equal() +   theme_void()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"color","dir":"Articles","previous_headings":"","what":"Color","title":"Anchor Points","text":"color section discusses paths’ starting direction, angle, length, documented distance percentage. values specify final color. values get generated paths, can thought points’ attributes. initial angle paths determines hue. following code example starts two directional values (x_direction y_direction), standardizes unit vector, finally uses atan2 get angle. example sets later code directional vectors drawn noise, rest procedure . randomly generated value hue_turn rotates colors. way, colors can end pointing direction. examples, variable set zero, follow traditional hue values. Angle Data distance value determines chroma. code need parameter 0 100, data mostly range symmetrically around 0, possibly -2 2. Using standard deviation data, pnorm function can convert values 0 1. multiplying 100 spreads across acceptable range. course, different effects come different distributions, one works nicely. (Also, ’s precisely chroma value color scheme angle maxes 63. See color scheme vignette.) Distance 1 Distance 2 Distance 3 Now angle distance examples set, actual code can investigated. get_vectors function generate paths simplex noise used initial angle. Notice familiar code x_direction y_direction. use diamond layout size 750 set anchor points. get_vectors function uses dataset, generates initial direction distance, calculates angle percentage, gets color. can pull result apart following sections. Point Attributes , can analyze angle values. angle 135 common, values 0 45 . colors show large green region little red. Angle Histogram Angle Map distance values range -1 1 pull. Notice highlights distance map match specific region earlier angle map. values unconnected. percentage values, however, function distance values. , strong match two maps exists. Distance Histogram Distance Map Percentage Histogram Percentage Map Finally, can plot angle percentage points see fall color scheme. plot shows lot points green hue, lot low percentage value end gray. result matches plot point attributes. Points Color Scheme","code":"seeds <- sample(1:10000, 3) hue_turn <- 0  angle_data <- expand_grid(   x_direction = seq(-1, 1, by = .5),   y_direction = seq(-1, 1, by = .5) ) %>%   mutate(vector_length = sqrt(x_direction^2 + y_direction^2)) %>%   mutate(     x_direction = x_direction / vector_length,     y_direction = y_direction / vector_length   ) %>%   select(-vector_length) %>%   mutate(angle = (atan2(y_direction, x_direction) * 180 / pi) %% 360 + hue_turn) %>%   filter(!is.na(angle)) %>%   distinct() %>%   mutate(     x = cos(angle * pi / 180),     y = sin(angle * pi / 180),     label_text = paste0(       \"x_direction = \", round(x_direction, 3),       \",\\n y_direction = \", round(y_direction, 3)     ),     hjust = if_else(x >= 0, -.15, 1.15),     vjust = if_else(y >= 0, -.05, 1.05),     text_angle = if_else(x >= 0, angle, angle + 180)   ) %>%   mutate(vjust = if_else(angle %in% c(0, 90, 180, 270), .5, vjust))  # basically just running around the unit circle ggplot(   data = angle_data,   aes(     x = x,     y = y,     color = angle,     label = label_text,     hjust = hjust,     vjust = vjust,     angle = text_angle   ) ) +   geom_point() +   geom_text(size = 1.25) +   scale_x_continuous(limits = c(-2.5, 2.5)) +   scale_y_continuous(limits = c(-2.5, 2.5)) +   coord_equal() +   theme(     text = element_text(size = 7.5),     legend.key.size = unit(.25, \"cm\")   ) distance_data <- data.frame(   distance_1 = rnorm(1000),   distance_2 = runif(1000, -1, 1),   distance_3 = c(rnorm(500), runif(500, -1, 1)) ) %>%   mutate(     distance_1 = pnorm(distance_1, 0, sd = sd(distance_1)) * 100,     distance_2 = pnorm(distance_2, 0, sd = sd(distance_2)) * 100,     distance_3 = pnorm(distance_3, 0, sd = sd(distance_3)) * 100   ) ggplot(   data = distance_data,   aes(x = distance_1) ) +   geom_histogram(bins = 25) ggplot(   data = distance_data,   aes(x = distance_2) ) +   geom_histogram(bins = 25) ggplot(   data = distance_data,   aes(x = distance_3) ) +   geom_histogram(bins = 25) get_vectors <- function(points, seeds) {   vectors <- points %>%     mutate(       x_direction = gen_simplex(x,         y,         frequency = .01,         seed = seeds[1]       ),       y_direction = gen_simplex(x,         y,         frequency = .01,         seed = seeds[2]       )     ) %>%     mutate(vector_length = sqrt(x_direction^2 + y_direction^2)) %>%     mutate(       x_direction = x_direction / vector_length,       y_direction = y_direction / vector_length     ) %>%     select(-vector_length) } size <- 750  grid_width <- ifelse(size <= 1500 / 2, ceiling(sqrt(size)), floor(sqrt(size)))  points <- expand_grid(   x_start = seq(1, grid_width) - (grid_width / 2) - .5,   y_start = seq(1, grid_width) - (grid_width / 2) - .5 ) %>%   mutate(     x = (x_start * cos(45 * pi / 180) - y_start * sin(45 * pi / 180)) * 5,     y = (x_start * sin(45 * pi / 180) + y_start * cos(45 * pi / 180)) * 5,     id = row_number()   ) %>%   select(-x_start, -y_start)  points <- get_vectors(points, seeds) %>%   mutate(distance = gen_simplex(points$x,     points$y,     frequency = .01,     seed = seeds[3]   )) %>%   mutate(     angle = (atan2(y_direction, x_direction) * 180 / pi) %% 360 + hue_turn,     percentage = pnorm(distance, mean = 0, sd = sd(distance)) * 100   ) %>%   rowwise() %>%   mutate(hex_color = flowfieldfigments::get_color(angle, percentage)) %>%   ungroup() %>%   mutate(     x_color = percentage * cos(angle * pi / 180),     y_color = percentage * sin(angle * pi / 180),     time = 0   ) %>%   filter(!is.na(hex_color))  axes_limits <- max(c(abs(c(   points$x,   points$y ))))  ggplot(   data = points,   aes(x, y, color = hex_color) ) +   geom_point(size = .5) +   scale_color_identity() +   scale_x_continuous(limits = c(-axes_limits, axes_limits)) +   scale_y_continuous(limits = c(-axes_limits, axes_limits)) +   coord_equal() +   theme_void() ggplot(   data = points,   aes(x = angle) ) +   geom_histogram(bins = 36) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) colors <- data.frame(angle = seq(0, 360, 30)) %>%   rowwise() %>%   mutate(color =             flowfieldfigments::get_color(              angle, 100)) %>%   pull(color)  ggplot(   data = points,   aes(x, y, color = angle) ) +   geom_point() +   scale_x_continuous(limits = c(-axes_limits,                                  axes_limits)) +   scale_y_continuous(limits = c(-axes_limits,                                  axes_limits)) +   coord_equal() +   theme_void() +   scale_colour_gradientn(     colors = colors,     breaks = seq(0, 360, 45)   ) ggplot(   data = points,   aes(x = distance) ) +   geom_histogram(bins = 25) ggplot(   data = points,   aes(x, y, color = distance) ) +   geom_point() +   scale_x_continuous(limits = c(-axes_limits,                                  axes_limits)) +   scale_y_continuous(limits = c(-axes_limits,                                  axes_limits)) +   coord_equal() +   theme_void() ggplot(   data = points,   aes(x = percentage) ) +   geom_histogram(bins = 25) ggplot(   data = points,   aes(x, y, color = percentage) ) +   geom_point() +   scale_x_continuous(limits = c(-axes_limits,                                  axes_limits)) +   scale_y_continuous(limits = c(-axes_limits,                                  axes_limits)) +   coord_equal() +   theme_void() circle <- data.frame(value = c(seq(0, 360, .5), 0)) %>%   mutate(x = 100 * cos(value * pi/180),          y = 100 * sin(value * pi/180))  ggplot() +   geom_polygon(data = circle,                aes(x, y),                color = \"black\",                fill = \"NA\") +   geom_point(data = points,              aes(x_color, y_color, color = hex_color)) +   scale_color_identity() +   coord_equal() +   theme_void()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"results-comparison","dir":"Articles","previous_headings":"","what":"Results comparison","title":"Anchor Points","text":"final section runs previous code different anchor layouts sizes. set, rows size 50, 750, 1,500. ’s trend angles following along diagonals flowing loops. noteworthy differences layout styles.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"random","dir":"Articles","previous_headings":"Results comparison","what":"Random","title":"Anchor Points","text":"set.seed(2) set.seed(3) set.seed(4) set.seed(5) set.seed(6) set.seed(7) set.seed(8) set.seed(9) set.seed(10)","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"spiral","dir":"Articles","previous_headings":"Results comparison","what":"Spiral","title":"Anchor Points","text":"set.seed(11) set.seed(12) set.seed(13) set.seed(14) set.seed(15) set.seed(16) set.seed(17) set.seed(18) set.seed(19)","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Anchor-Points.html","id":"diamond","dir":"Articles","previous_headings":"Results comparison","what":"Diamond","title":"Anchor Points","text":"set.seed(20) set.seed(21) set.seed(22) set.seed(23) set.seed(24) set.seed(25) set.seed(26) set.seed(27) set.seed(28)","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Color-Schemes.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Color Schemes","text":"vignette walks creating color scheme flowfieldfigments. cover setup, adjustments, comparison base color scheme followed subsetting. steps result creating get_color get_color_subset functions. color scheme project needs span hues stretch gray higher saturation keeping saturation somewhat even across hue values. addition , flow field paths determine colors starting directions lengths. ’ll use HCL color space hue, chroma, luminance parameters. Hue chroma span colors stretch gray higher saturation. addition, path’s starting direction can map hue length chroma. main requirements met, now details need determined.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Color-Schemes.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Color Schemes","text":"need enforce evenness chroma across hue values. , ’ll design disk centered 0 chroma 0 hue, try stretch maximize width. following code retrieves max chroma value across hues. can see odd shape top view range luminance values side views. Notice 0 chroma 0 hue center, ring points form flat plane. Top View Side View 1 Side View 2 get flat plane, ’ll use PCA. technique balance odd shape max chromas. (techniques produce satisfying results, , like regression optimization.) ’ll use PCA loadings construct function, luminance_function, takes x y values return luminance values plane. Combining function lot hue/chroma combinations give us maximum size disk. now plane max size, 63 max_dist, disk. can wrap function see looks. ’ll use PCA loadings convert hue values right direction. can see circle centered (0, 0), stretches edges, tilted max chroma ring. max chroma shape circle don’t connect circle hits edge HCL color space hull. Top View Side View 1 Side View 2","code":"library(tidyverse) library(colorspace)  # Set up all the max chromas hue <- seq(0, 359.5, .5) luminance <- seq(0, 100, .5)  max_chroma_luminance <- function(h) {   mc <- max_chroma(h, l = seq(0, 100, .5))   ml <- seq(0, 100, .5)[mc == max(mc)]   data.frame(     hue = h,     chroma = max(mc),     luminance = ml   ) }  df <- map_dfr(hue, max_chroma_luminance)  df <- df %>%   mutate(     x = chroma * cos(hue * pi / 180),     y = chroma * sin(hue * pi / 180),     hex_color = hcl(hue, chroma, luminance)   )  ggplot(   data = df,   aes(x, y, color = hex_color) ) +   geom_point() +   scale_color_identity() +   coord_equal() df <- df %>%   arrange(-y)  ggplot(   data = df,   aes(x, luminance,     color = hex_color   ) ) +   geom_point() +   scale_color_identity() +   scale_y_continuous(limits = c(0, 100)) +   coord_equal() df <- df %>%   arrange(x)  ggplot(   data = df,   aes(y, luminance,     color = hex_color   ) ) +   geom_point() +   scale_color_identity() +   scale_y_continuous(limits = c(0, 100)) +   coord_equal() # Use PCA to get a plane df_pca <- df %>%   select(     -hex_color,     -hue,     -chroma   ) %>%   relocate(x, y, luminance)  pca <- princomp(df_pca)  # Work out a*x + b*y + c*luminance = d comp3 <- as.vector(pca$loadings)[7:9] a <- comp3[1] b <- comp3[2] c <- comp3[3] d <- comp3[1] * mean(df_pca$x) +   comp3[2] * mean(df_pca$y) +   comp3[3] * mean(df_pca$luminance)  # Solve for luminance given x, y luminance_function <- function(x, y) {   (d - x * a - y * b) / c }  # Test luminance_function(0, 0) #> [1] 74.84433  # Get max chroma max_dist <- expand_grid(   hue = seq(0, 360, .5),   chroma = seq(0, 180) ) %>%   mutate(     x = chroma * cos(hue * pi / 180),     y = chroma * sin(hue * pi / 180)   ) %>%   rowwise() %>%   mutate(luminance = luminance_function(x, y)) %>%   filter(luminance <= 100) %>%   mutate(hex_color = hcl(hue, chroma, luminance, fixup = FALSE)) %>%   filter(!is.na(hex_color)) %>%   mutate(base_lum = luminance_function(0, 0)) %>%   mutate(     dist = sqrt(x^2 + y^2 + (luminance - base_lum)^2),     hue_round = round(hue)   ) %>% # base_x, base_y = 0   group_by(hue_round) %>%   mutate(max_dist = max(dist)) %>%   ungroup() %>%   summarize(floor(min(max_dist))) %>%   pull() max_dist #> [1] 63 v1 <- pca$loadings[c(1, 2, 3)] v1 <- v1 / sqrt(sum(v1^2)) v2 <- pca$loadings[c(4, 5, 6)] v2 <- v2 / sqrt(sum(v2^2)) v3 <- pca$loadings[c(7, 8, 9)] v3 <- v3 / sqrt(sum(v3^2)) p <- c(0, 0, luminance_function(0, 0))  get_values <- function(hue) {   v <- p +     max_dist * cos(hue * pi / 180) * v1 +     max_dist * sin(hue * pi / 180) * v2   data.frame(     x = v[1],     y = v[2],     luminance = v[3],     old_hue = hue   ) }  df_circle <- map_dfr(hue, get_values) %>%   mutate(     hue = (atan2(y, x) * 180 / pi) %% 360,     chroma = sqrt(x^2 + y^2)   ) %>%   mutate(hex_color = hcl(hue, chroma, luminance, fixup = FALSE))  df_total <- df_circle %>%   select(-old_hue) %>%   rbind(df) %>%   arrange(-luminance)  ggplot() +   geom_point(     data = df_total,     aes(x, y, color = hex_color)   ) +   geom_point() +   scale_color_identity() +   coord_equal() df_total <- df_total %>%   arrange(-y)  ggplot() +   geom_point(     data = df_total,     aes(x, luminance,       color = hex_color     )   ) +   scale_color_identity() +   scale_y_continuous(limits = c(0, 100)) +   coord_equal() df_total <- df_total %>%   arrange(x)  ggplot() +   geom_point(     data = df_total,     aes(y, luminance,       color = hex_color     )   ) +   scale_color_identity() +   scale_y_continuous(limits = c(0, 100)) +   coord_equal()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Color-Schemes.html","id":"adjustments","dir":"Articles","previous_headings":"","what":"Adjustments","title":"Color Schemes","text":"One aspect setup don’t like hue values function little matching 0 0. Everything gets slightly turned process vectors used. , can rotate vectors 0 hue input return 0 hue output. action doesn’t anything final results, makes debugging little easier colors line expected.  vectors get magic numbers get_color function package. want take moment double-check distances around disk. maximum 63 hue values. Running along hue values, getting color, converting HCL, x-y, finally, distance center shows edge values around 63. ’s precisely 63 color space conversions jitter everything, close enough. exercise indicates disk tilted, values keep chroma hue change luminance. Circle Check Distances Circle Check Colors","code":"ggplot(data = df_circle, aes(   x = old_hue,   y = hue )) +   geom_point() # Now fix so hue = 0 returns hue = 0 # hue = 0 # means y = 0 # means v[2] = 0 # means p[2] + chroma * cos(0) * v1[2] + chroma * sin(0) * v2[2] = 0 # p[2] = 0, sin(0) = 0 # just need v1[2] to be 0  # got center of circle, p # need point on circle where y = 0, x is positive p <- c(0, 0, luminance_function(0, 0)) i_vector <- c(1, 0, luminance_function(1, 0)) i_vector <- (i_vector - p) / sqrt(sum((i_vector - p)^2)) j_vector <- c(   v3[2] * i_vector[3] - v3[3] * i_vector[2],   v3[3] * i_vector[1] - v3[1] * i_vector[3],   v3[1] * i_vector[2] - v3[2] * i_vector[1] )  # These are the magic numbers in the get_color function i_vector #> [1]  0.9925801  0.0000000 -0.1215926 j_vector #> [1] 0.01725933 0.98987471 0.14089068 p #> [1]  0.00000  0.00000 74.84433 get_color <- function(angle, percentage) {   vectors <- data.frame(     v1 = c(       0.99258009214842,       0,       -0.121592601216663     ),     v2 = c(       0.0172593263893888,       0.989874705747223,       0.14089067596698     ),     p = c(       0,       0,       74.8443331534229     )   )    v <- vectors[[\"p\"]] +     (percentage / 100 * 63) * cos(angle * pi / 180) * vectors[[\"v1\"]] +     (percentage / 100 * 63) * sin(angle * pi / 180) * vectors[[\"v2\"]]    hue <- (atan2(v[2], v[1]) * 180 / pi) %% 360   chroma <- sqrt(v[1]^2 + v[2]^2)   luminance <- v[3]    grDevices::hcl(hue, chroma, luminance, fixup = FALSE) } circle_check <- data.frame(angle = seq(0, 360, .5)) %>%   mutate(percentage = 100) %>%   rowwise() %>%   mutate(hex_color = get_color(angle, percentage)) %>%   mutate(     L = coords(as(hex2RGB(hex_color), \"polarLUV\"))[, 1],     C = coords(as(hex2RGB(hex_color), \"polarLUV\"))[, 2],     H = coords(as(hex2RGB(hex_color), \"polarLUV\"))[, 3]   ) %>%   mutate(     hex_color_2 = hcl(H, C, L),     x = C * cos(H * pi / 180),     y = C * sin(H * pi / 180)   ) %>%   mutate(distance = sqrt(x^2 + y^2 + (L - 74.8443331534229)^2)) ggplot(   data = circle_check,   aes(x, y, color = distance) ) +   geom_point() +   coord_equal() +   theme(legend.position = \"bottom\") ggplot(   data = circle_check,   aes(x, y, color = hex_color) ) +   geom_point() +   coord_equal() +   scale_color_identity()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Color-Schemes.html","id":"comparison","dir":"Articles","previous_headings":"","what":"Comparison","title":"Color Schemes","text":"last task section compare using flat luminance value. Basically, instead work, difference just using flat disk. can pick base luminance value 78.844, get_color(0, 0). Color Scheme Flat Luminance noticeable differences : Brighter greens yellows Darker violets disk extends full value can compute difference using color scheme versus flat luminance outputs inputs. graph shows direction magnitude disk’s tilt. areas considerable differences match considerable differences last two charts. Difference Comparison","code":"golden <- ((sqrt(5) + 1) / 2) * (2 * pi)  size <- 10000 color_scheme_points <- data.frame(   x = sqrt(seq(1, size)) * cos(golden * seq(1, size)) * 2.5,   y = sqrt(seq(1, size)) * sin(golden * seq(1, size)) * 2.5 ) %>%   mutate(     angle = atan2(y, x) * 180 / pi,     distance = sqrt(x^2 + y^2)   ) %>%   mutate(percentage = distance / max(distance) * 100) %>%   rowwise() %>%   mutate(hex_color = get_color(angle, percentage))  flat_luminance_points <- data.frame(   x = sqrt(seq(1, size)) * cos(golden * seq(1, size)) * 2.5,   y = sqrt(seq(1, size)) * sin(golden * seq(1, size)) * 2.5 ) %>%   mutate(     angle = atan2(y, x) * 180 / pi,     distance = sqrt(x^2 + y^2)   ) %>%   mutate(percentage = distance / max(distance) * 100) %>%   rowwise() %>%   mutate(hex_color = hcl(     h = angle,     c = percentage / 100 * 63,     l = 74.8443331534229,     fixup = FALSE   )) %>%   filter(!is.na(hex_color)) ggplot() +   geom_point(     data = color_scheme_points,     aes(x, y,       color = hex_color     )   ) +   scale_color_identity() +   coord_equal() +   theme_void() ggplot() +   geom_point(     data = flat_luminance_points,     aes(x, y,       color = hex_color     )   ) +   scale_color_identity() +   coord_equal() +   theme_void() compare_points <- data.frame(   x = sqrt(seq(1, size)) *     cos(golden * seq(1, size)) * 2.5,   y = sqrt(seq(1, size)) *     sin(golden * seq(1, size)) * 2.5 ) %>%   mutate(     angle = atan2(y, x) * 180 / pi,     distance = sqrt(x^2 + y^2)   ) %>%   mutate(percentage = distance / max(distance) * 100) %>%   rowwise() %>%   mutate(hex_color_cs = get_color(angle, percentage)) %>%   mutate(hex_color_fl = hcl(     h = angle,     c = percentage / 100 * 63,     l = 74.8443331534229,     fixup = FALSE   )) %>%   filter(!is.na(hex_color_fl)) %>%   mutate(     L_cs = coords(as(hex2RGB(hex_color_cs), \"polarLUV\"))[, 1],     C_cs = coords(as(hex2RGB(hex_color_cs), \"polarLUV\"))[, 2],     H_cs = coords(as(hex2RGB(hex_color_cs), \"polarLUV\"))[, 3],     L_fl = coords(as(hex2RGB(hex_color_fl), \"polarLUV\"))[, 1],     C_fl = coords(as(hex2RGB(hex_color_fl), \"polarLUV\"))[, 2],     H_fl = coords(as(hex2RGB(hex_color_fl), \"polarLUV\"))[, 3]   ) %>%   mutate(     x_cs = C_cs * cos(H_cs * pi / 180),     y_cs = C_cs * sin(H_cs * pi / 180),     x_fl = C_fl * cos(H_fl * pi / 180),     y_fl = C_fl * sin(H_fl * pi / 180)   ) %>%   mutate(difference = sign(L_cs - L_fl) * sqrt((x_cs - x_fl)^2 +     (y_cs - y_fl)^2 +     (L_cs - L_fl)^2))  ggplot(   data = compare_points,   aes(x, y, color = difference) ) +   geom_point() +   coord_equal() +   theme(legend.position = \"bottom\")"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Color-Schemes.html","id":"subsetting","dir":"Articles","previous_headings":"","what":"Subsetting","title":"Color Schemes","text":"finish vignette, need cover get_color_subset function. function warps standard input get_color output subset continuous hue values. transforms hue angle centered center bounded center - width center + width. hue moves 0 360, output colors start center, move along center + width, turn back center, move center - width, finally back center. Color Scheme Subset Changing center width parameters can move colors around color wheel shrink expand range colors. output continuous set, subset colors next color wheel. Larger Angle Hue Change","code":"get_color_subset <- function(center, width, angle, percentage) {   get_color(width * sin(angle * pi / 180) + center, percentage) }  size <- 10000  points <- data.frame(   x = sqrt(seq(1, size)) * cos(golden * seq(1, size)) * 2.5,   y = sqrt(seq(1, size)) * sin(golden * seq(1, size)) * 2.5 ) %>%   mutate(id = row_number()) %>%   mutate(     percentage = sqrt(x^2 + y^2),     angle = atan2(y, x) * 180 / pi   ) %>%   mutate(percentage = percentage / max(percentage) * 100) %>%   rowwise() %>%   mutate(hex_color = get_color_subset(0, 30, angle, percentage))  ggplot(   data = points,   aes(x, y, color = hex_color) ) +   geom_point() +   scale_color_identity() +   coord_equal() +   theme_void() points <- points %>%   mutate(     hex_color =       get_color_subset(         0,         90,         angle,         percentage       )   )  ggplot(   data = points,   aes(x, y, color = hex_color) ) +   geom_point() +   scale_color_identity() +   coord_equal() +   theme_void() points <- points %>%   mutate(     hex_color =       get_color_subset(         180,         60,         angle,         percentage       )   )  ggplot(   data = points,   aes(x, y, color = hex_color) ) +   geom_point() +   scale_color_identity() +   coord_equal() +   theme_void()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Miscellanea.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Miscellanea","text":"vignette covers rest code finish project. following code snippets display happens package.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Miscellanea.html","id":"point-paths","dir":"Articles","previous_headings":"","what":"Point Paths","title":"Miscellanea","text":"Sometimes points won’t travel generated plateau. cases, also won’t show paths data set filtered won’t show segments. ’ll need create points points graph separately. function create appropriate data set.","code":"get_point_paths <- function(points, paths) {   # Handle paths that were dropped because they didn't go anywhere   point_paths <- points %>%     anti_join(paths, by = \"id\") %>%     mutate(       hex_color = get_color(0, 0),       alpha_value = 1     ) }"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Miscellanea.html","id":"alpha-taper","dir":"Articles","previous_headings":"","what":"Alpha Taper","title":"Miscellanea","text":"png files, three options alpha taper. start sets alpha lowest value beginning, end sets end, fades directions. Note: based code , default.","code":"if (alpha_taper == \"start\") {   paths <- paths %>%     group_by(id) %>%     mutate(alpha_value = 1 - (max(time) - time) /       (max(time) + 1)) %>%     ungroup() } else if (alpha_taper == \"end\") {   paths <- paths %>%     group_by(id) %>%     mutate(alpha_value = 1 - (time / (max(time) + 1))) %>%     ungroup() } else {   paths <- paths %>%     group_by(id) %>%     mutate(alpha_value = 1 - (abs(time - median(time)) /       (median(time) + 1))) %>%     ungroup() }"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Miscellanea.html","id":"movement","dir":"Articles","previous_headings":"","what":"Movement","title":"Miscellanea","text":"gif mp4 files, two movement options, march glide. operate creating subset path data set render step. march graphs little bit path time. time moves forward, parts paths. glide, option, stretches along entire path shrinks anchor point end.","code":"if (movement == \"march\") {   max_frame <- max(paths$time) + 9   for (frame in 0:max_frame) { # check max time plus something     sub_paths <- paths %>%       ungroup() %>%       filter(time > frame - 10 & time <= frame) %>%       mutate(alpha_value = 1 - (max(time) - time) / 10)      if (frame <= 10) {       point_paths <- point_paths %>%         mutate(alpha_value = (10 - frame) / 10)     } else {       point_paths <- point_paths[0, ]     }     ## ggplot code here   } } else {   max_frame <- max(paths$time) * 2   for (frame in 0:max_frame) {     if (frame <= max_frame / 2) {       sub_paths <- paths %>%         filter(time <= frame)     } else {       sub_paths <- paths %>%         filter(time >= frame - max_frame / 2)            point_paths <- point_paths[0, ]     }     ## ggplot code here   } }"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Paths.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Paths","text":"vignette develops paths. topics include introducing simplex noise, functions move anchor points, investigating direction correlations. Reading vignettes first helpful.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Paths.html","id":"simplex-noise","dir":"Articles","previous_headings":"","what":"Simplex Noise","title":"Paths","text":"create paths points follow, package uses noise-generating functions ambient package. functions make smooth terrain points can flow . Saving step graphing draws paths. many functions, several parameters, can combined ton options. However, package uses one type simplex noise. ’ll need generate points see action. Points Setup code grid, x y values scaled 5. scale set amount movement paths ’m trying find. paths similar points close together. far apart, different. scale almost every number depend attempting. ’s really mathematical optimization . ’s just playing around parameters get something like. following line actually generates noise. takes x y values locations. frequency parameter sets much movement happens, seed parameter ensures exact results can occur. feature important second. Simplex Histogram Simplex Map results show noise values -1 1, tend slope ends, also multimodal. attributes typically hold set points noise-generating function, even different seed, won’t always happen options. map right shows terrain. Using noise create paths, ’ll move higher values lower ones. However, package use different technique. understand importance seed parameter, can move points seed different one see happens. Moving points seed generates almost map. ’s terrain, view shifted points. movement different seed yields entirely different map. new map won’t usable paths need follow hills valleys. Therefore, code requires seed parameter generate noise values points use move. feature nice points don’t move along grid can end anywhere. Simplex Map Movement Seed Simplex Map Movement Different Seed great use noise terrain, really need slope elevation get movement. gradient_noise function ambient probably best choice , decided see options. ’s possible take noise wrap angle. However, run noise function can different bounds. , struggle set values angles without gaps large directions. Angle Attempt following code section tries different techniques transform noise values angles. Unfortunately, problems gaps significant modes values. didn’t like project, desirable attributes something else. pnorm(sd = .25) pnorm(sd = .25) logistic pnorm(sd = .25) pnorm(sd = .25) logistic Using simplex noise flawed provides one dimension, really need two, one x movement one y. , let’s just use two simplex noises, one direction. (Agina, options resolve want one function, like curl noise.) following graphs show movement x-direction y-direction. different locations hills valleys, ranges similar. simplex noise function parameters, except seed, results similar smoothness. X Movement Y Movement can standardize movements step distance. useful set points distances far paths go. , standardized movements render angle. following graphs standardized movements show directions’ values affect . blend two previous graphs remaining different. also larger range movement sharper changes direction. X Movement Standardized Y Movement Standardized starting directions work. primarily smooth transitions one arrow neighbor. areas little change areas lot. Also, notice block (-40, 0) (0, 40) lot smoother block (-20, -20) (20, 20). reason, (0, 0) always lot action. suspect something simplex noise generation process origin. Angle Map Finally, see overall angle distribution. histogram shows large values around 225, smaller previous graph one mode. also lack values 270, ’s complete gap 0. Angle Histogram Now mechanism get direction spot, can use create paths.","code":"library(tidyverse) library(ambient) library(purrr)  points <- expand_grid(   x = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5,   y = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5 ) %>%   mutate(     x = x * 5, # get to the right scale     y = y * 5,     id = dplyr::row_number()   )  ggplot(   data = points,   aes(x, y) ) +   geom_point(size = .5) +   coord_equal() points <- points %>%   mutate(noise = gen_simplex(x,     y,     frequency = .01,     seed = 1   )) ggplot(   data = points,   aes(noise) ) +   geom_histogram(bins = 25) ggplot(   data = points,   aes(x, y, fill = noise) ) +   geom_tile() +   coord_equal() points_move <- points %>%   mutate(     x = x + 1,     y = y + 1   ) %>%   mutate(noise = gen_simplex(x,     y,     frequency = .01,     seed = 1   ))  ggplot(   data = points_move,   aes(x, y, fill = noise) ) +   geom_tile() +   coord_equal() points_move <- points %>%   mutate(     x = x + 1,     y = y + 1   ) %>%   mutate(noise = gen_simplex(x,     y,     frequency = .01,     seed = 2   ))  ggplot(   data = points_move,   aes(x, y, fill = noise) ) +   geom_tile() +   coord_equal() ggplot(   data = points,   aes(noise) ) +   geom_histogram(bins = 25) +   coord_polar() points <- points %>%   mutate(     angle_1 = (pnorm(noise, sd = .25) * 360),     angle_2 = (pnorm(noise, sd = .5) * 360),     angle_3 = (1 / (1 + exp(-noise / .25)) * 360)   ) ggplot(   data = points,   aes(angle_1) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) ggplot(   data = points,   aes(angle_2) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) ggplot(   data = points,   aes(angle_3) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) ggplot(   data = points,   aes(angle_1) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) ggplot(   data = points,   aes(angle_2) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) ggplot(   data = points,   aes(angle_3) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) points <- expand_grid(   x = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5,   y = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5 ) %>%   mutate(     x = x * 5, # get to the right scale     y = y * 5,     id = dplyr::row_number()   )  points <- points %>%   mutate(     x_direction = gen_simplex(x,       y,       frequency = .01,       seed = 1     ),     y_direction = gen_simplex(x,       y,       frequency = .01,       seed = 2     )   ) ggplot(   data = points,   aes(x, y, fill = x_direction) ) +   geom_tile() +   scale_fill_continuous(limits = c(-1, 1)) +   coord_equal() ggplot(   data = points,   aes(x, y, fill = y_direction) ) +   geom_tile() +   scale_fill_continuous(limits = c(-1, 1)) +   coord_equal() points <- points %>%   mutate(vector_length = sqrt(x_direction^2 +     y_direction^2)) %>%   mutate(     x_direction = x_direction / vector_length,     y_direction = y_direction / vector_length   ) %>%   select(-vector_length) %>%   mutate(angle = (atan2(y_direction, x_direction) * 180 / pi) %% 360) ggplot(   data = points,   aes(x, y, fill = x_direction) ) +   geom_tile() +   scale_fill_continuous(limits = c(-1, 1)) +   coord_equal() ggplot(   data = points,   aes(x, y, fill = y_direction) ) +   geom_tile() +   scale_fill_continuous(limits = c(-1, 1)) +   coord_equal() ggplot(   data = points,   aes(x, y,        xend = x + x_direction,       yend = y + y_direction,       color = angle) ) +   geom_segment(arrow = arrow(length = unit(0.033, \"inches\"))) +   scale_colour_gradient2(     low = \"darkblue\",     mid = \"lightblue\",     high = \"darkblue\",     midpoint = 180,     breaks = seq(0, 360, 90)   ) +   coord_equal() ggplot(   data = points,   aes(angle) ) +   geom_histogram(bins = 25) +   scale_x_continuous(     limits = c(0, 360),     oob = scales::oob_keep,     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Paths.html","id":"moving-points","dir":"Articles","previous_headings":"","what":"Moving Points","title":"Paths","text":"Danielle Navarro’s “Art, jasmines, water colours” post heavily influenced section. highly recommend reading understand code better see another way use flow fields generative art. ’ll create two helper functions: one get directions one add movement points. get_vectors uses points’ current location set seeds return direction points move. move_points adds distances points updates time. Following points along time values display paths. two functions can written one just need paths. Setting colors uses get_vectors move_points, ’ll stay separated project. ’ll now create primary function, get_paths, uses two functions. function uses accumulate purrr package. ’ll start set points, apply move_points 100 times pass seeds get noise values. action returns data frame step, ’ll bind together. Lastly, ’ll get next step along paths filter points don’t next step need shortened based percentage value. Points next step end move completely flat area get stopped. (percentage comes setting points, see vignette.) Now can reset points, get seeds, try function. First, ’ll set percentage values 50. paths length example. output, can see step point takes looking x, y, xend, yend end section, can finally see paths. square anchor points still visible, lot variability points end get . Paths Example","code":"get_vectors <- function(points, seeds) {   vectors <- points %>%     mutate(       x_direction = gen_simplex(x,         y,         frequency = .01,         seed = seeds[1]       ),       y_direction = gen_simplex(x,         y,         frequency = .01,         seed = seeds[2]       )     ) %>%     mutate(vector_length = sqrt(x_direction^2 +       y_direction^2)) %>%     mutate(       x_direction = x_direction / vector_length,       y_direction = y_direction / vector_length     ) %>%     select(-vector_length) }  move_points <- function(points, seeds) {   points <- points %>%     get_vectors(seeds) %>%     mutate(       x = x + x_direction * .5,       y = y + y_direction * .5,       time = time + 1     )   return(points) } get_paths <- function(points, seeds) {   paths <- accumulate(     .x = rep(list(seeds), 100), # up to 100 for max percentage     .f = move_points,     .init = points   )   paths <- bind_rows(paths)   paths <- paths %>%     group_by(id) %>%     mutate(       xend = lead(x),       yend = lead(y)     ) %>%     filter(!is.na(xend)) %>%     filter(time <= percentage) } points <- expand_grid(   x = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5,   y = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5 ) %>%   mutate(     x = x * 5,     y = y * 5,     id = dplyr::row_number()   )  set.seed(10000) seeds <- sample(1:10000, 3)  points <- get_vectors(points, seeds) %>%   mutate(     time = 0,     percentage = 50   )  paths <- get_paths(points, seeds)  paths <- paths %>%   arrange(id, time)  head(paths) #> # A tibble: 6 × 9 #> # Groups:   id [1] #>       x     y    id x_direction y_direction  time percentage  xend  yend #>   <dbl> <dbl> <int>       <dbl>       <dbl> <dbl>      <dbl> <dbl> <dbl> #> 1 -67.5 -67.5     1       0.447      -0.894     0         50 -67.3 -67.9 #> 2 -67.3 -67.9     1       0.447      -0.894     1         50 -67.1 -68.4 #> 3 -67.1 -68.4     1       0.435      -0.900     2         50 -66.8 -68.9 #> 4 -66.8 -68.9     1       0.423      -0.906     3         50 -66.6 -69.3 #> 5 -66.6 -69.3     1       0.411      -0.912     4         50 -66.4 -69.8 #> 6 -66.4 -69.8     1       0.399      -0.917     5         50 -66.2 -70.2 axes_limits <- max(c(abs(c(   paths$x,   paths$y,   paths$xend,   paths$yend ))))  ggplot(   data = paths,   aes(     x = x,     y = y,     xend = xend,     yend = yend   ) ) +   geom_segment() +   coord_equal()"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/articles/Paths.html","id":"common-directions","dir":"Articles","previous_headings":"","what":"Common directions","title":"Paths","text":"can look steps taken see patterns. example, angles common. Paths Example Let’s set 100 attempts previous code aggregate . 100 Attempts end, graph displays prominent trends diagonals. least two reasons appear (suspect might ). possible movement values range around -1 1 direction standardizing. sets square possible combinations. combinations along diagonals cardinal directions. , diagonals appear often. strange correlations simplex noise values. hills valleys two terrains sometimes match top . situations (anywhere difference absolute value close) hit along diagonal. like strong tendency diagonal movement, options want code. First, can add random rotation constant (like happens hue setting colors), spin trend away diagonals. Using weighting scheme x y directions, possibly using another round simplex noise, can break apart correlations. Finally, different parameters simplex noise noise-generating functions can different properties.","code":"paths_direcion <- paths %>%   ungroup() %>%   mutate(angle = (atan2(y_direction, x_direction) * 180 / pi) %% 360) %>%   mutate(angle = cut_interval(angle, n = 20, labels = FALSE) * (36 / 2) - (36 / 4)) %>%   group_by(angle) %>%   summarise(count = n())  ggplot(   data = paths_direcion,   aes(x = angle, y = count) ) +   geom_bar(     stat = \"identity\",     width = 36 / 2   ) +   scale_x_continuous(     limits = c(0, 360),     breaks = seq(0, 360, 45)   ) +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) paths_direcion_score <- data.frame(   run_id = integer(),   angle = numeric(),   count = integer() )  for (i in seq(1, 100)) {   seeds <- sample(1:10000, 3)    points <- expand_grid(     x = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5,     y = seq(1, ceiling(sqrt(750))) - (ceiling(sqrt(750)) / 2) - .5   ) %>%     mutate(       x = x * 5, # get to the right scale       y = y * 5,       id = dplyr::row_number()     )    points <- get_vectors(points, seeds) %>%     mutate(       time = 0,       percentage = 50     )    paths <- get_paths(points, seeds)    paths_direcion <- paths %>%     ungroup() %>%     mutate(angle = (atan2(y_direction, x_direction) * 180 / pi) %% 360) %>%     mutate(angle = cut_interval(angle, n = 20, labels = FALSE) * (36 / 2) - (36 / 4)) %>%     group_by(angle) %>%     summarise(count = n()) %>%     mutate(run_id = i)    paths_direcion_score <- paths_direcion_score %>%     rbind(paths_direcion) }  paths_direcion_score_summary <- paths_direcion_score %>%   group_by(angle) %>%   summarize(     angle_quantile = quantile(count, seq(.1, 1, .1), q = seq(.1, 1, .1)),     .groups = \"keep\"   ) %>%   mutate(     quantile = rank(angle_quantile),     angle_quantile_difference = angle_quantile - lag(angle_quantile)   ) %>%   mutate(angle_quantile_difference = if_else(is.na(angle_quantile_difference),     angle_quantile,     angle_quantile_difference   ))  ggplot(   data = paths_direcion_score_summary,   aes(     x = angle,     y = angle_quantile_difference,     fill = quantile   ) ) +   geom_bar(     stat = \"identity\",     width = 36 / 2   ) +   scale_x_continuous(\"angle\",     limits = c(0, 360),     breaks = seq(0, 360, 45)   ) +   scale_y_continuous(\"count\") +   coord_polar(     direction = -1,     start = 270 * pi / 180   ) +   scale_fill_gradient2(     \"Decile\",     low = \"lightgray\",     mid = \"black\",     high = \"lightgray\",     midpoint = 5,     space = \"Lab\",     na.value = \"grey50\",     guide = \"colourbar\",     aesthetics = \"fill\"   )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tyler Bradley. Author, maintainer.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bradley T (2022). flowfieldfigments: Flow Field Generative Art. R package version 0.0.0.9000, https://williamtylerbradley.github.io/flowfieldfigments/.","code":"@Manual{,   title = {flowfieldfigments: Flow Field Generative Art},   author = {Tyler Bradley},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://williamtylerbradley.github.io/flowfieldfigments/}, }"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/index.html","id":"flowfieldfigments-","dir":"","previous_headings":"","what":"Flow Field Generative Art","title":"Flow Field Generative Art","text":"flowfieldsfigments package creates png gif files generative art.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Flow Field Generative Art","text":"can install released version flowfieldfigments GitHub :","code":"install.packages(\"devtools\") devtools::install_github(\"WilliamTylerBradley/flowfieldfigments\")"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/index.html","id":"articles","dir":"","previous_headings":"","what":"Articles","title":"Flow Field Generative Art","text":"See Articles information generative process. includes understanding color scheme creation, anchor points design, paths determination, odds ends, full script can easily pulled apart.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/index.html","id":"website","dir":"","previous_headings":"","what":"Website","title":"Flow Field Generative Art","text":"https://williamtylerbradley.github.io/flowfieldfigments/","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_gif.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a gif file — create_gif","title":"Creates a gif file — create_gif","text":"Creates gif file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_gif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a gif file — create_gif","text":"","code":"create_gif(   seeds,   size,   anchor_layout,   hue_turn,   color_scheme,   color_subset_center,   color_subset_width,   movement,   output_file )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_gif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a gif file — create_gif","text":"seeds Values set random seeds gen_simplex. size Number points. anchor_layout Either \"random\", \"spiral\", \"diamond\". hue_turn Degree rotate hue values. color_scheme Either \"subset\" \"full\" hue range. color_subset_center Center hue value using subset color_scheme color_subset_width Width hue value using subset color_scheme movement Determines paths animated. Options \"march\" \"glide\". \"march\" moves small parts along path. \"glide\" fills path entirely shrinks away. output_file File save gif.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_gif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a gif file — create_gif","text":"gif file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_mp4.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a mp4 file — create_mp4","title":"Creates a mp4 file — create_mp4","text":"Creates mp4 file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_mp4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a mp4 file — create_mp4","text":"","code":"create_mp4(   seeds,   size,   anchor_layout,   hue_turn,   color_scheme,   color_subset_center,   color_subset_width,   movement,   output_file )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_mp4.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a mp4 file — create_mp4","text":"seeds Values set random seeds gen_simplex. size Number points. anchor_layout Either \"random\", \"spiral\", \"diamond\". hue_turn Degree rotate hue values. color_scheme Either \"subset\" \"full\" hue range. color_subset_center Center hue value using subset color_scheme color_subset_width Width hue value using subset color_scheme movement Determines paths animated. Options \"march\" \"glide\". \"march\" moves small parts along path. \"glide\" fills path entirely shrinks away. output_file File save mp4","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_mp4.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a mp4 file — create_mp4","text":"mp4 file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_png.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a png file — create_png","title":"Creates a png file — create_png","text":"Creates png file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_png.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a png file — create_png","text":"","code":"create_png(   seeds,   size,   anchor_layout,   hue_turn,   color_scheme,   color_subset_center,   color_subset_width,   alpha_taper,   output_file )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_png.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a png file — create_png","text":"seeds Values set random seeds gen_simplex. size Number points. anchor_layout Either \"random\", \"spiral\", \"diamond\". hue_turn Degree rotate hue values. color_scheme Either \"subset\" \"full\" hue range. color_subset_center Center hue value using subset color_scheme color_subset_width Width hue value using subset color_scheme alpha_taper Direction paths taper. Options \"start\", \"end\", \"\". \"start\" fades away anchor points \"end\" fades away opposite direction. \"\" fades direction. output_file File save png.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/create_png.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a png file — create_png","text":"png file","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_anchor_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function to get the starting points and their attributes. — get_anchor_points","title":"Internal function to get the starting points and their attributes. — get_anchor_points","text":"Internal function get starting points attributes.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_anchor_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function to get the starting points and their attributes. — get_anchor_points","text":"","code":"get_anchor_points(   seeds,   size,   anchor_layout,   hue_turn,   color_scheme,   color_subset_center,   color_subset_width )"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_anchor_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function to get the starting points and their attributes. — get_anchor_points","text":"seeds Values set random seeds gen_simplex. size Number points. anchor_layout Either \"random\", \"spiral\", \"diamond\". hue_turn Degree rotate hue values. color_scheme Either \"subset\" \"full\" hue range. color_subset_center Center hue value using subset color_scheme color_subset_width Width hue value using subset color_scheme","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_anchor_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function to get the starting points and their attributes. — get_anchor_points","text":"Dataframe points attributes","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the hex code color based on angle and percentage. — get_color","title":"Gets the hex code color based on angle and percentage. — get_color","text":"flowfieldsfigment uses base color scheme covering hues.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the hex code color based on angle and percentage. — get_color","text":"","code":"get_color(angle, percentage)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the hex code color based on angle and percentage. — get_color","text":"angle Angle degrees [0, 360]. Closely matches hue HCL. percentage Percent [0, 100]. Closely matches chroma HCL.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the hex code color based on angle and percentage. — get_color","text":"Hex code color value.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets the hex code color based on angle and percentage. — get_color","text":"","code":"get_color(0, 80) #> [1] \"#E092A1\" get_color(90, 50) #> [1] \"#C5C89D\""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","title":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","text":"function converts color scheme use subset hues. get_color_subset maps angle center 0 180 stretch center - width 90 center + width 270.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","text":"","code":"get_color_subset(center, width, angle, percentage)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","text":"center Center hue angle [0, 360] color scheme. width Width angles center edge hue values. angle Angle degrees [0, 360]. Closely matches hue HCL. percentage Percent [0, 100]. Closely matches chroma HCL.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","text":"Hex code color value.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_color_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets the hex code color from get_color augmented by center and width. — get_color_subset","text":"","code":"get_color_subset(90, 30, 90, 100) #> [1] \"#ABE894\" get_color_subset(180, 90, 270, 80) #> [1] \"#CCD188\""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function to get the points' full paths. — get_paths","title":"Internal function to get the points' full paths. — get_paths","text":"starts points along paths. Paths shorten either points hit plateau (vectors 0 x y) filtered percentage.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function to get the points' full paths. — get_paths","text":"","code":"get_paths(points, seeds)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function to get the points' full paths. — get_paths","text":"points Current position points. seeds Values set random seeds gen_simplex.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function to get the points' full paths. — get_paths","text":"Dataframe paths.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_point_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function to handle edge case of when points start on a plateau. — get_point_paths","title":"Internal function to handle edge case of when points start on a plateau. — get_point_paths","text":"Internal function handle edge case points start plateau.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_point_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function to handle edge case of when points start on a plateau. — get_point_paths","text":"","code":"get_point_paths(points, paths)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_point_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function to handle edge case of when points start on a plateau. — get_point_paths","text":"points Current position points. paths Paths points take.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_point_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function to handle edge case of when points start on a plateau. — get_point_paths","text":"Dataframe points attributes time 0.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function to get directional vectors. — get_vectors","title":"Internal function to get directional vectors. — get_vectors","text":"function uses ambient package generate noise points follow.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function to get directional vectors. — get_vectors","text":"","code":"get_vectors(points, seeds)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function to get directional vectors. — get_vectors","text":"points Current position points. seeds Values set random seeds gen_simplex.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/get_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function to get directional vectors. — get_vectors","text":"direction vectors points move.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/move_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function to move points by one time period. — move_points","title":"Internal function to move points by one time period. — move_points","text":"function uses get_vectors determine points go.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/move_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function to move points by one time period. — move_points","text":"","code":"move_points(points, seeds)"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/move_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function to move points by one time period. — move_points","text":"points Current position points. seeds Values set random seeds gen_simplex.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/move_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function to move points by one time period. — move_points","text":"next steps points.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://williamtylerbradley.github.io/flowfieldfigments/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
